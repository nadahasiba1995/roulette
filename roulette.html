
            <html lang="en">
                    <head>
                      <meta charset="utf-8">
                      <meta http-equiv="X-UA-Compatible" content="IE=edge">
                      <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
                      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/6.2.3/foundation.css">
                      <title>دولاب الحظ</title>
                  <style>
@font-face {
  font-family: "GeDinar";
  src: url("font/GE Dinar One Medium.otf");
  }


 html, body {
  height: auto;
  font-family: GeDinar !important;

}

body {
  /* #d5d3a7 */
  background-image: linear-gradient(to bottom, #7cceb1, #7948dc );
  background-repeat: no-repeat;
  color: #fff;
}

.mount svg {
  display: block;
  max-width: 100%;
  margin: 0 auto;
  width: 900px;
  min-width: 400px;
  max-height: 700px;
  transform: rotate(270deg);
  /* position:absolute;
  left: 50%;
  transform: translateX(-50%); */
}

.mount{
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
  width: inherit !important;
}


.row {
  max-width: 520px;
}
.container{margin:auto; height: 100vh;}

 @media (max-width: 1200px) and (min-width: 700px){
  .mount {
    width: 100% !important;
    
}
 }



path {

  stroke: white;
  stroke-width: 2px;

  stroke-linejoin: round;
}

text {
    font-family: inherit;
}

button.button.expanded.js-spin {
    position: absolute;
    left: 50%;
    top: 50%;
    z-index: 1;
    width: 60px;
    height: 60px;
    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    transform: translate(-50%,-50%);
    border: none;
    border-radius: 50%;
    background-image: url(logo.png);
  display: inline-block;
  background-position:center;
  background-size: contain;
  background-repeat: no-repeat;
  background-color:white; 
    -moz-user-select:none;
        -ms-user-select:none;
        -webkit-user-select:none;
        user-select:none;
        -webkit-tap-highlight-color: rgba(0,0,0,0);
 
}

button:focus {outline:0;}


                  </style>
          
                      </head>
                      <body>
                        

                        <div align="center" class="container">
                            
<div class="mount js-mount">    
  <button class="button expanded js-spin"></button></div><br/>
<div class="row">
  <div class="column small-12">
 
    <textarea class="js-words" name="words" rows="3" style="display:none">مبروك الناموس/ياك الخير/يا رباه ربحت/السموحة/وش هالحظ/ حظ أوفر /حل السؤال/حاول مجدداً</textarea>
    <button class="button expanded js-get-word"  style="display:none">Get current word</button>
 
  </div>
</div>
</div>
                          <script type="text/javascript" src="javascript.js"></script>
                        <script src="https://code.jquery.com/jquery-3.4.0.js" integrity="sha256-DYZMCC8HTC+QDr5QNaIcfR7VSPtcISykd+6eSmBW5qo="crossorigin="anonymous"></script>
                          <script>
 console.clear();
const log = (...args) => console.log(args);

// FACTORY
const COLORS = [
  '#f7d046',
  '#ff4c5a',
  '#f08cba',
  '#49c4d2',
  '#924e84',
  '#fd926f',
  '#245a65',
  '#ff6a76',
  '#633d89',
];
const PI = Math.PI;
const TAU = PI * 2;

const degToRad = deg => deg / 180 * PI;

const getCoordOnCircle = (r, angleInRad, {cx, cy}) => {
  return {
    x: cx + r * Math.cos(angleInRad),
    y: cy + r * Math.sin(angleInRad),
  };
};

const wheelFactory = mountElem => {
  if (!mountElem || !('nodeType' in mountElem)) {
    throw new Error('no mount element provided');
  }

  const eventMap = {
    mousedown: handleCursorDown,
    touchstart: handleCursorDown,
    mousemove: handleCursorMove,
    touchmove: handleCursorMove,
    mouseup: handleCursorUp,
    touchend: handleCursorUp,
  };
  const ratios = {
    tickerRadius: 0.06, // of width
    textSize: 0.12, // of radius
    edgeDist: 0.14, // of radius
  };
  let options = {
    width: 360,
    height: 360,
    type: 'svg',
  };
  const friction = 0.95;
  const maxSpeed = 0.5;
  let isGroupActive = false;
  let curPosArr = [];
  let dirScalar = 1;
  let lastCurTime;
  let speed;
  let words;
  let two;
  let group;

  function init(opts) {
    options = {...options, ...opts};
    two = new Two({
      type: Two.Types[options.type],
      width: options.width,
      height: options.height,
    })
      .bind('resize', handleResize)
      .play();

    initEvents();
    two.appendTo(mountElem);
    setViewBox(options.width, options.height);
    two.renderer.domElement.setAttribute(
      'style',
      `
        -moz-user-select:none;
        -ms-user-select:none;
        -webkit-user-select:none;
        user-select:none;
        -webkit-tap-highlight-color: rgba(0,0,0,0);
      `
    );
  }

  function setWords(wordsArr) {
    words = wordsArr;
  }

  function setViewBox(width, height) {
    two.renderer.domElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
  }

  function drawTicker() {
    const {width} = two;
    const outerRadius = ratios.tickerRadius * width;

    const tickerCircle = drawTickerCircle(outerRadius);
    const circleCenter = tickerCircle.translation;

    drawTickerArrow(outerRadius, degToRad(30), circleCenter);
  }

  function drawTickerCircle(outerRadius) {
    const {height, width} = two;
    const arc = two.makeArcSegment(
      width - outerRadius,
      height / 2,
      outerRadius,
      outerRadius * 0.5,
      0,
      2 * PI
    );
    arc.noStroke();
    
    return arc;
  }

  function drawTickerArrow(radius, tangentAngle, tickerCenter) {
    const {x, y} = tickerCenter;

    const pointA = getCoordOnCircle(radius, PI, {cx: x, cy: y});
    const pointB = getCoordOnCircle(radius, PI / 2 + tangentAngle, {
      cx: x,
      cy: y,
    });
    const pointC = {
      x: x - radius / Math.cos(PI / 2 - tangentAngle),
      y: y,
    };
    const pointD = getCoordOnCircle(radius, 3 * PI / 2 - tangentAngle, {
      cx: x,
      cy: y,
    });
    const path = two.makePath(
      pointA.x,
      pointA.y,
      pointB.x,
      pointB.y,
      pointC.x,
      pointC.y,
      pointD.x,
      pointD.y
    );
    path.noStroke();

    return path;
  }

  function drawWheel() {
    if (group) {
      destroyPaths();
    }

    const {width} = two;
    const numColors = COLORS.length;
    const rotationUnit = 2 * PI / words.length;
    const xOffset = width * ratios.tickerRadius * 2;
    const radius = (width - xOffset * 2) / 2;
    const center = {
      x: width / 2,
      y: radius + xOffset,
    };
    group = two.makeGroup();

    words.map((word, i, arr) => {
      const angle = rotationUnit * i - (PI + rotationUnit) / 2;
      const arc = two.makeArcSegment(
        center.x,
        center.y,
        0,
        radius,
        0,
        2 * PI / arr.length
      );
      arc.rotation = angle;
      arc.noStroke();
      arc.fill = COLORS[i % numColors];

      const textVertex = {
        x:
          center.x +
          (radius - radius * ratios.edgeDist) *
            Math.cos(angle + rotationUnit / 2),
        y:
          center.y +
          (radius - radius * ratios.edgeDist) *
            Math.sin(angle + rotationUnit / 2),
      };

      const text = two.makeText(word, textVertex.x, textVertex.y);
      text.rotation = rotationUnit * i - PI / 2;
      text.alignment = 'right';
      text.fill = '#fff';
      text.size = radius * ratios.textSize;

      return group.add(arc, text);
    });

    group.translation.set(center.x, center.y);
    group.center();
    drawTicker();

    two.update();


// g.addEventListener('webkitTransitionEnd', myFunction);
// g.addEventListener('transitionend', myFunction);
  }

//   const g = document.querySelectorAll('g');
//   g.addEventListener( "click", function( evt ) {
//     msg.textContent = "'" + evt.target.id + "' got poked, and 'green' was" +
    
//     // access to the event path
//     ( ~evt.path.indexOf( green ) ? "" : "n't" ) +
    
//     " in the path.";
// }, false );

$(document).on('click','g',function(){
  $(this).addClass("animate");
  $(this).one("webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend",
              function(event) {
    // Do something when the transition ends
  });
});

  function handleResize() {
    setViewBox(two.width, two.height);
    drawWheel();
    drawTicker();
    two.update();
  }

  function handleCursorDown(e) {
    const groupElem = group._renderer.elem;

    isGroupActive = groupElem === e.target || groupElem.contains(e.target);
    curPosArr = isGroupActive ? curPosArr.concat(getEventPos(e)) : curPosArr;
    lastCurTime = performance.now();
    
  }

  function handleCursorMove(e) {
    if (isGroupActive && curPosArr.length) {
      e.preventDefault();
      lastCurTime = performance.now();
      curPosArr = curPosArr.concat(getEventPos(e));
      const currPos = curPosArr[curPosArr.length - 1];
      const prevPos = curPosArr[curPosArr.length - 2];
      const groupBounds = group._renderer.elem.getBoundingClientRect();
      const groupCenter = {
        x: groupBounds.left + groupBounds.width / 2,
        y: groupBounds.top + groupBounds.height / 2,
      };
      const angleAtCursorDown = Math.atan2(
        prevPos.y - groupCenter.y,
        prevPos.x - groupCenter.x
      );
      const angleAtCursorNow = Math.atan2(
        currPos.y - groupCenter.y,
        currPos.x - groupCenter.x
      );
      const deltaRotation = angleAtCursorNow - angleAtCursorDown;
      dirScalar = deltaRotation > 0 ? 1 : -1;

      group.rotation = (group.rotation + deltaRotation) % TAU;

      handleRotationChange(group.rotation);

      two.update();

    }
  }

  function handleCursorUp(e) {
    if (isGroupActive && curPosArr.length > 1) {
      const currPos = getEventPos(e);
      const lastPos = curPosArr[curPosArr.length - 2];
      const timeNow = performance.now();
      const time = timeNow - lastCurTime;
      const distance = Math.sqrt(
        Math.pow(currPos.x - lastPos.x, 2) + Math.pow(currPos.y - lastPos.y, 2)
      );
      speed = Math.min(distance / time, maxSpeed);
   
      two.bind('update', animateWheel);
    }

    curPosArr = [];
    isGroupActive = false;
  }

  function getEventPos(e) {
    const {clientX: x, clientY: y} = getEvent(e);

    return {x, y};
  }

  function getEvent(e) {
  
    return e.changedTouches ? e.changedTouches[0] : e;
  }

  function animateWheel() {
    group.rotation = (group.rotation + speed * dirScalar) % TAU;
    speed = speed * friction;
  

    handleRotationChange(group.rotation);

    if (speed < 0.005) {
      two.unbind('update', animateWheel);
    }
    
  }

  function handleRotationChange(angle) {
    if (options.onWheelTick && typeof options.onWheelTick === 'function') {
      options.onWheelTick(angle);
    }
    

    
  }

  function spin(newSpeed) {
    speed = newSpeed;
    two.bind('update', animateWheel);
    
   
  }

  function updateDims({height, width}) {
    two.width = parseInt(width, 10);
    two.height = parseInt(height, 10);
    two.trigger('resize');
     
  }

  function getCurrentWord() {
    const numWords = words.length;
    const segmentAngle = TAU / numWords;
    const currAngle = (TAU + PI / 2 - group.rotation + segmentAngle / 2) % TAU;
    return words.find((_, i) => segmentAngle * (i + 1) > currAngle);

  }

  function initEvents() {
    const domElement = two.renderer.domElement;

    Object.keys(eventMap).map(type =>
      domElement.addEventListener(type, eventMap[type])
    );
  }

  function removeEvents() {
    const domElement = two.renderer.domElement;
     two.unbind('update');

    Object.keys(eventMap).map(type =>
      domElement.removeEventListener(type, eventMap[type])
    );
  }

  function destroyPaths() {
   
    group.remove.apply(group, group.children);
    two.clear();
    
  }

  function destroy() {
    destroyPaths();
    removeEvents();
   
    return true;
  }

  return {
    destroy,
    drawWheel,
    getCurrentWord,
    init,
    setWords,
    spin,
    updateDims,
  };
};


// DOM
const mount = document.querySelector('.js-mount');
const wordButton = document.querySelector('.js-get-word');
const spinButton = document.querySelector('.js-spin');
const wordsInput = document.querySelector('.js-words');
const getWords = () => wordsInput.value.split('/');
 
wordsInput.addEventListener('input', handleChange);
wordButton.addEventListener('click', handleGetWord);
spinButton.addEventListener('click', handleSpin);

const wheel = wheelFactory(mount);
wheel.init({
  width: Math.min(window.innerWidth, window.innerHeight),
  height: Math.min(window.innerWidth, window.innerHeight),
  onWheelTick: () => console.log('tick'),
});
wheel.setWords(getWords());
wheel.drawWheel();

function handleChange(e) {
  const { target } = e;
  const words = target.value.split('/');

  wheel.setWords(words);
  wheel.drawWheel();
}

function handleGetWord(e) {
  const word = wheel.getCurrentWord();
  
  e.target.textContent = `Get current word: ${word}`;
}

function handleSpin() {
  wheel.spin(Math.random());
 
}


function myFunction(){
  alert("ended");
}

window.addEventListener('resize', () => {
  wheel.updateDims({
    width: Math.min(window.innerWidth, window.innerHeight),
    height: Math.min(window.innerWidth, window.innerHeight),
  });
});



  

 </script>
 </body>
</html>